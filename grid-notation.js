// Generated by CoffeeScript 1.10.0
(function() {
  var Command, GridNotation, Unit, error, find, lengthOf, trim,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  GridNotation = (function() {
    function GridNotation(args) {
      if (args == null) {
        args = {};
      }
      this.stringifyParams = bind(this.stringifyParams, this);
      this.stringifyCommands = bind(this.stringifyCommands, this);
      this.parseVariable = bind(this.parseVariable, this);
      this.parseParams = bind(this.parseParams, this);
      this.parseGrid = bind(this.parseGrid, this);
      this.isCommands = bind(this.isCommands, this);
      this.validate = bind(this.validate, this);
      this.objectify = bind(this.objectify, this);
      this.test = bind(this.test, this);
      this.stringify = bind(this.stringify, this);
      this.clean = bind(this.clean, this);
      this.unit = new Unit();
      this.cmd = new Command();
    }

    GridNotation.prototype.parse = function(string, info) {
      var adjust, adjustRemainder, command, explicit, explicitSum, fill, fillCollection, fillIterations, fillWidth, gn, grid, guideOrientation, guides, i, insertMarker, j, k, key, l, len, len1, len2, len3, len4, len5, len6, len7, len8, length, m, measuredWidth, n, newCommand, newCommands, o, offset, originalWidth, p, percentValue, percents, q, r, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref3, ref4, ref5, ref6, ref7, ref8, ref9, remainderOffset, remainderPixels, s, stretchDivisions, t, tested, v, variable, wholePixels, wildcardArea, wildcardWidth, wildcards;
      if (string == null) {
        string = "";
      }
      if (info == null) {
        info = {};
      }
      if (info.resolution) {
        this.unit.resolution = info.resolution;
      }
      this.cmd.unit = this.unit;
      guides = [];
      tested = this.validate(this.objectify(string));
      if (tested.errors.length > 0) {
        return null;
      }
      gn = tested.obj;
      ref = gn.variables;
      for (key in ref) {
        variable = ref[key];
        gn.variables[key] = this.expandCommands(variable, {
          variables: gn.variables
        });
      }
      ref1 = gn.grids;
      for (j = 0, len = ref1.length; j < len; j++) {
        grid = ref1[j];
        guideOrientation = grid.params.orientation;
        wholePixels = grid.params.calculation === 'p';
        fill = find(grid.commands, function(el) {
          return el.isFill;
        })[0] || null;
        originalWidth = guideOrientation === 'h' ? info.height : info.width;
        measuredWidth = guideOrientation === 'h' ? info.height : info.width;
        if ((ref2 = grid.params.width) != null ? (ref3 = ref2.unit) != null ? ref3.base : void 0 : void 0) {
          measuredWidth = grid.params.width.unit.base;
        }
        offset = guideOrientation === 'h' ? info.offsetY : info.offsetX;
        stretchDivisions = 0;
        adjustRemainder = 0;
        wildcardArea = measuredWidth;
        grid.commands = this.expandCommands(grid.commands, gn.variables);
        wildcards = find(grid.commands, function(el) {
          return el.isWildcard;
        });
        if ((ref4 = grid.params.width) != null ? (ref5 = ref4.unit) != null ? ref5.base : void 0 : void 0) {
          adjustRemainder = originalWidth - ((ref6 = grid.params.width) != null ? ref6.unit.base : void 0);
        }
        percents = find(grid.commands, function(el) {
          return el.isPercent;
        });
        ref7 = gn.variables;
        for (k in ref7) {
          v = ref7[k];
          percents = percents.concat(find(v, function(el) {
            return el.isPercent;
          }));
        }
        for (l = 0, len1 = percents.length; l < len1; l++) {
          command = percents[l];
          percentValue = measuredWidth * (command.unit.value / 100);
          if (wholePixels) {
            percentValue = Math.floor(percentValue);
          }
          command.unit = this.unit.parse(percentValue + "px");
        }
        explicit = find(grid.commands, function(el) {
          return el.isExplicit && !el.isFill;
        });
        explicitSum = 0;
        for (m = 0, len2 = explicit.length; m < len2; m++) {
          command = explicit[m];
          explicitSum += command.unit.base;
        }
        wildcardArea -= explicitSum;
        if (fill) {
          length = lengthOf(fill, gn.variables);
          fillIterations = 0;
          if (length > 0) {
            fillIterations = Math.floor(wildcardArea / length);
          }
          fillCollection = [];
          fillWidth = 0;
          for (i = n = 1, ref8 = fillIterations; 1 <= ref8 ? n <= ref8 : n >= ref8; i = 1 <= ref8 ? ++n : --n) {
            if (fill.isVariable) {
              fillCollection = fillCollection.concat(gn.variables[fill.id]);
              fillWidth += lengthOf(fill, gn.variables);
            } else {
              newCommand = this.cmd.parse(this.cmd.toSimpleString(fill));
              fillCollection.push(newCommand);
              fillWidth += newCommand.unit.base;
            }
          }
          wildcardArea -= fillWidth;
          newCommands = [];
          ref9 = grid.commands;
          for (i = o = 0, len3 = ref9.length; o < len3; i = ++o) {
            command = ref9[i];
            if (command.isFill) {
              newCommands = newCommands.concat(fillCollection);
            } else {
              newCommands.push(command);
            }
          }
          grid.commands = [].concat(newCommands);
        }
        explicit = find(grid.commands, function(el) {
          return el.isExplicit && !el.isFill;
        });
        explicitSum = 0;
        for (p = 0, len4 = explicit.length; p < len4; p++) {
          command = explicit[p];
          explicitSum += command.unit.base;
        }
        if (((ref10 = grid.params.width) != null ? (ref11 = ref10.unit) != null ? ref11.base : void 0 : void 0) == null) {
          if (wildcards.length === 0) {
            adjustRemainder = originalWidth - explicitSum;
          }
          wildcardArea -= ((ref12 = grid.params.firstOffset) != null ? (ref13 = ref12.unit) != null ? ref13.base : void 0 : void 0) || 0;
          wildcardArea -= ((ref14 = grid.params.lastOffset) != null ? (ref15 = ref14.unit) != null ? ref15.base : void 0 : void 0) || 0;
        }
        if (adjustRemainder > 0) {
          adjustRemainder -= ((ref16 = grid.params.firstOffset) != null ? (ref17 = ref16.unit) != null ? ref17.base : void 0 : void 0) || 0;
          adjustRemainder -= ((ref18 = grid.params.lastOffset) != null ? (ref19 = ref18.unit) != null ? ref19.base : void 0 : void 0) || 0;
        }
        if ((ref20 = grid.params.firstOffset) != null ? ref20.isWildcard : void 0) {
          stretchDivisions++;
        }
        if ((ref21 = grid.params.lastOffset) != null ? ref21.isWildcard : void 0) {
          stretchDivisions++;
        }
        adjust = adjustRemainder / stretchDivisions;
        if ((ref22 = grid.params.firstOffset) != null ? ref22.isWildcard : void 0) {
          if (wholePixels) {
            adjust = Math.ceil(adjust);
          }
          grid.params.firstOffset = this.cmd.parse(adjust + "px");
        }
        if ((ref23 = grid.params.lastOffset) != null ? ref23.isWildcard : void 0) {
          if (wholePixels) {
            adjust = Math.floor(adjust);
          }
          grid.params.lastOffset = this.cmd.parse(adjust + "px");
        }
        offset += ((ref24 = grid.params.firstOffset) != null ? ref24.unit.base : void 0) || 0;
        if (wildcardArea && wildcards) {
          wildcardWidth = wildcardArea / wildcards.length;
          if (wholePixels) {
            wildcardWidth = Math.floor(wildcardWidth);
            remainderPixels = wildcardArea % wildcards.length;
          }
          for (q = 0, len5 = wildcards.length; q < len5; q++) {
            command = wildcards[q];
            command.isWildcard = false;
            command.isExplicit = true;
            command.isFill = true;
            command.multiplier = 1;
            command.isPercent = false;
            command.unit = this.unit.parse(wildcardWidth + "px");
          }
        }
        if (remainderPixels) {
          remainderOffset = 0;
          if (grid.params.remainder === 'c') {
            remainderOffset = Math.floor((wildcards.length - remainderPixels) / 2);
          }
          if (grid.params.remainder === 'l') {
            remainderOffset = wildcards.length - remainderPixels;
          }
          for (i = r = 0, len6 = wildcards.length; r < len6; i = ++r) {
            command = wildcards[i];
            if (i >= remainderOffset && i < remainderOffset + remainderPixels) {
              command.unit = this.unit.parse((wildcardWidth + 1) + "px");
            }
          }
        }
        insertMarker = offset;
        newCommands = [];
        ref25 = grid.commands;
        for (i = s = 0, len7 = ref25.length; s < len7; i = ++s) {
          command = ref25[i];
          if (!command.isGuide || (command.isGuide && !((ref26 = grid.commands[i - 1]) != null ? ref26.isGuide : void 0))) {
            newCommands.push(command);
          }
        }
        grid.commands = [].concat(newCommands);
        ref27 = grid.commands;
        for (t = 0, len8 = ref27.length; t < len8; t++) {
          command = ref27[t];
          if (command.isGuide) {
            guides.push({
              location: insertMarker,
              orientation: guideOrientation
            });
          } else {
            insertMarker += command.unit.base;
          }
        }
      }
      return guides;
    };

    GridNotation.prototype.clean = function(string) {
      var gn, grid, j, key, len, line, ref, ref1, variable;
      if (string == null) {
        string = "";
      }
      gn = this.validate(this.objectify(string)).obj;
      string = "";
      ref = gn.variables;
      for (key in ref) {
        variable = ref[key];
        string += key + " = " + (this.stringifyCommands(variable)) + "\n";
      }
      if (gn.variables.length > 0) {
        string += "\n";
      }
      ref1 = gn.grids;
      for (j = 0, len = ref1.length; j < len; j++) {
        grid = ref1[j];
        line = "";
        line += this.stringifyCommands(grid.commands);
        line += " " + (this.stringifyParams(grid.params));
        string += (trim(line)) + "\n";
      }
      return trim(string.replace(/\n\n\n+/g, "\n"));
    };

    GridNotation.prototype.stringify = function(data) {
      var column, firstMargString, gridString, gutter, lastMargString, left, optionsString, right, unit, varString;
      data || (data = {});
      data.count = parseInt(data.count);
      data.width || (data.width = '');
      data.gutter || (data.gutter = '');
      data.firstMargin || (data.firstMargin = '');
      data.lastMargin || (data.lastMargin = '');
      data.columnMidpoint || (data.columnMidpoint = false);
      data.gutterMidpoint || (data.gutterMidpoint = false);
      data.orientation || (data.orientation = 'v');
      data.position || (data.position = 'f');
      data.remainder || (data.remainder = 'l');
      data.calculation || (data.calculation = '');
      firstMargString = '';
      varString = '';
      gridString = '';
      lastMargString = '';
      optionsString = '';
      if (data.firstMargin) {
        firstMargString = '|' + data.firstMargin.replace(/,|\s+/g, ' ').split(' ').join('|') + '|';
      }
      if (data.lastMargin) {
        lastMargString = '|' + data.lastMargin.replace(/,|\s+/g, ' ').split(' ').reverse().join('|') + '|';
      }
      if (data.count || data.width) {
        column = data.width ? data.width : '~';
        if (data.columnMidpoint) {
          left = right = '~';
          if (data.width) {
            unit = this.unit.parse(data.width);
            left = "" + (data.calculation === 'p' && unit.type === 'px' ? Math.floor(unit.value / 2) : unit.value / 2) + unit.type;
            right = "" + (data.calculation === 'p' && unit.type === 'px' ? Math.ceil(unit.value / 2) : unit.value / 2) + unit.type;
          }
          column = left + "|" + right;
        }
        varString += "$" + data.orientation + " = |" + column + "|\n";
        if (data.gutter && data.count !== 1) {
          gutter = data.gutter ? data.gutter : '~';
          if (data.gutterMidpoint) {
            left = right = '~';
            if (data.gutter) {
              unit = this.unit.parse(data.gutter);
              left = "" + (data.calculation === 'p' && unit.type === 'px' ? Math.floor(unit.value / 2) : unit.value / 2) + unit.type;
              right = "" + (data.calculation === 'p' && unit.type === 'px' ? Math.ceil(unit.value / 2) : unit.value / 2) + unit.type;
            }
            gutter = left + "|" + right;
          }
          varString = "$" + data.orientation + " = |" + column + "|" + gutter + "|\n";
          varString += "$" + data.orientation + "C = |" + column + "|\n";
        }
      }
      if (data.count || data.width) {
        gridString += "|$" + data.orientation;
        if (data.count !== 1) {
          gridString += "*";
        }
        if (data.count > 1 && data.gutter) {
          gridString += data.count - 1;
        }
        if (data.count > 1 && !data.gutter) {
          gridString += data.count;
        }
        gridString += "|";
        if (data.gutter && data.count !== 1) {
          gridString += "|$" + data.orientation + (data.gutter ? 'C' : '') + "|";
        }
      }
      if ((!data.count && !data.width) && data.firstMargin) {
        gridString += "|";
      }
      if ((!data.count && !data.width) && (data.firstMargin || data.lastMargin)) {
        gridString += "~";
      }
      if ((!data.count && !data.width) && data.lastMargin) {
        gridString += "|";
      }
      if (data.firstMargin || data.lastMargin || data.count || data.width) {
        optionsString += " ( ";
        optionsString += data.orientation;
        optionsString += data.remainder;
        if (data.calculation === "p") {
          optionsString += "p";
        }
        optionsString += ", ";
        if (data.position === "l" || data.position === "c") {
          optionsString += "~";
        }
        optionsString += "|";
        if (data.position === "f" || data.position === "c") {
          optionsString += "~";
        }
        optionsString += " )";
      }
      return this.pipeCleaner(("" + varString + firstMargString + gridString + lastMargString + optionsString).replace(/\|+/g, "|"));
    };

    GridNotation.prototype.test = function(string) {
      return this.validate(this.objectify(string)).errors;
    };

    GridNotation.prototype.objectify = function(string) {
      var grid, grids, j, len, line, lines, variable, variables;
      if (string == null) {
        string = "";
      }
      lines = string.split(/\n/g);
      string = "";
      variables = {};
      grids = [];
      for (j = 0, len = lines.length; j < len; j++) {
        line = lines[j];
        if (/^\$.*?\s?=.*$/i.test(line)) {
          variable = this.parseVariable(line);
          variables[variable.id] = variable.commands;
        } else if (/^\s*#/i.test(line)) {

        } else {
          grid = this.parseGrid(line);
          if (grid.commands.length > 0) {
            grids.push(grid);
          }
        }
      }
      return {
        variables: variables,
        grids: grids
      };
    };

    GridNotation.prototype.validate = function(obj) {
      var command, commands, errors, fills, first, grid, id, j, key, l, last, len, len1, ref, ref1, ref2, varHasFill, varHasWildcard, variable, variablesWithWildcards, width;
      variablesWithWildcards = {};
      errors = [];
      if (obj.grids.length <= 0) {
        error(2, errors);
      }
      ref = obj.variables;
      for (key in ref) {
        commands = ref[key];
        for (j = 0, len = commands.length; j < len; j++) {
          command = commands[j];
          if (command.errors.length > 0) {
            error(command.errors, errors);
          }
          id = command.id;
          if (id) {
            variable = obj.variables[id];
          }
          if (id && !variable) {
            error(6, errors, command);
          }
          if (command.isFill) {
            error(5, errors, command);
          }
          if (command.isWildcard) {
            variablesWithWildcards[key] = true;
          }
        }
      }
      ref1 = obj.grids;
      for (key in ref1) {
        grid = ref1[key];
        fills = 0;
        first = grid.params.firstOffset;
        width = grid.params.width;
        last = grid.params.lastOffset;
        if (first && first.errors.length > 0) {
          error(1, errors);
        }
        if (width && width.errors.length > 0) {
          error(1, errors);
        }
        if (last && last.errors.length > 0) {
          error(1, errors);
        }
        ref2 = grid.commands;
        for (l = 0, len1 = ref2.length; l < len1; l++) {
          command = ref2[l];
          if (command.errors.length > 0) {
            error(command.errors, errors);
          }
          id = command.id;
          if (id) {
            variable = obj.variables[id];
          }
          if (id && !variable) {
            error(6, errors, command);
          }
          varHasWildcard = find(variable, function(el) {
            return el.isWildcard;
          }).length > 0;
          if (command.isFill && varHasWildcard) {
            error(3, errors, command);
          }
          if (command.isFill) {
            fills++;
          }
          varHasFill = find(variable, function(el) {
            return el.isFill;
          }).length > 0;
          if (id && variable && varHasFill) {
            fills++;
          }
          if (fills > 1) {
            error(4, errors, command);
          }
          if (id && variable && varHasFill) {
            error(5, errors, command);
          }
        }
      }
      return {
        errors: errors.sort(),
        obj: obj
      };
    };

    GridNotation.prototype.parseCommands = function(string) {
      var commands, j, len, token, tokens;
      if (string == null) {
        string = "";
      }
      string = this.pipeCleaner(string);
      commands = [];
      if (string === "") {
        return commands;
      }
      tokens = string.replace(/^\s+|\s+$/g, '').replace(/\s\s+/g, ' ').split(/\s/);
      for (j = 0, len = tokens.length; j < len; j++) {
        token = tokens[j];
        commands.push(this.cmd.parse(token));
      }
      return commands;
    };

    GridNotation.prototype.expandCommands = function(commands, variables) {
      var command, i, j, l, len, len1, loops, m, newCommands, ref, reparse, varWidths;
      if (commands == null) {
        commands = [];
      }
      if (variables == null) {
        variables = {};
      }
      if (typeof commands === "string") {
        commands = this.parseCommands(commands);
      }
      reparse = true;
      varWidths = {};
      while (reparse === true) {
        reparse = false;
        newCommands = [];
        for (j = 0, len = commands.length; j < len; j++) {
          command = commands[j];
          if (command.isFill) {
            newCommands.push(command);
          } else {
            loops = command.multiplier || 1;
            for (i = l = 0, ref = loops; l < ref; i = l += 1) {
              newCommands.push(this.cmd.parse(this.cmd.toSimpleString(command)));
            }
          }
        }
        commands = [].concat(newCommands);
        newCommands = [];
        for (i = m = 0, len1 = commands.length; m < len1; i = ++m) {
          command = commands[i];
          if (command.isVariable && variables && variables[command.id] && !command.isFill) {
            reparse = true;
            newCommands = newCommands.concat(variables[command.id]);
          } else {
            newCommands.push(command);
          }
        }
        commands = [].concat(newCommands);
      }
      return commands;
    };

    GridNotation.prototype.isCommands = function(string) {
      var commands;
      if (string == null) {
        string = "";
      }
      if (string === "") {
        return false;
      }
      if (string.indexOf("|") >= 0) {
        return true;
      }
      commands = this.parseCommands(string);
      if (commands.length > 1) {
        return true;
      }
      if (commands[0].errors.length === 0) {
        return true;
      }
      return false;
    };

    GridNotation.prototype.parseGrid = function(string) {
      var commands, params, regex;
      if (string == null) {
        string = "";
      }
      regex = /\((.*?)\)/i;
      params = regex.exec(string) || [];
      string = trim(string.replace(regex, ''));
      commands = this.parseCommands(string);
      return {
        commands: commands,
        wildcards: find(commands, function(el) {
          return el.isWildcard;
        }),
        params: this.parseParams(params[1] || '')
      };
    };

    GridNotation.prototype.parseParams = function(string) {
      var bits, k, obj, ref, ref1, ref2, ref3, v;
      if (string == null) {
        string = "";
      }
      bits = string.replace(/[\s\(\)]/g, '').split(',');
      obj = {
        orientation: "h",
        remainder: "l",
        calculation: ""
      };
      if (bits.length > 1) {
        ref = this.parseOptions(bits[0]);
        for (k in ref) {
          v = ref[k];
          obj[k] = v;
        }
        ref1 = this.parseAdjustments(bits[1] || "");
        for (k in ref1) {
          v = ref1[k];
          obj[k] = v;
        }
        return obj;
      } else if (bits.length === 1) {
        if (this.isCommands(bits[0])) {
          ref2 = this.parseAdjustments(bits[0] || "");
          for (k in ref2) {
            v = ref2[k];
            obj[k] = v;
          }
        } else {
          ref3 = this.parseOptions(bits[0]);
          for (k in ref3) {
            v = ref3[k];
            obj[k] = v;
          }
        }
      }
      return obj;
    };

    GridNotation.prototype.parseOptions = function(string) {
      var j, len, obj, option, options;
      if (string == null) {
        string = "";
      }
      options = string.split('');
      obj = {};
      for (j = 0, len = options.length; j < len; j++) {
        option = options[j];
        switch (option.toLowerCase()) {
          case "h":
          case "v":
            obj.orientation = option;
            break;
          case "f":
          case "c":
          case "l":
            obj.remainder = option;
            break;
          case "p":
            obj.calculation = option;
        }
      }
      return obj;
    };

    GridNotation.prototype.parseAdjustments = function(string) {
      var adj, bits, el, end, i, j, len, ref, ref1;
      if (string == null) {
        string = "";
      }
      adj = {
        firstOffset: null,
        width: null,
        lastOffset: null
      };
      if (string === "") {
        return adj;
      }
      bits = this.expandCommands(string.replace(/\s/, '')).splice(0, 5);
      end = bits.length - 1;
      if (bits.length > 1 && !bits[end].isGuide) {
        adj.lastOffset = bits[end];
      }
      if (!bits[0].isGuide) {
        adj.firstOffset = bits[0];
      }
      for (i = j = 0, len = bits.length; j < len; i = ++j) {
        el = bits[i];
        if (((ref = bits[i - 1]) != null ? ref.isGuide : void 0) && ((ref1 = bits[i + 1]) != null ? ref1.isGuide : void 0)) {
          if (!el.isGuide) {
            adj.width = el;
          }
        }
      }
      return adj;
    };

    GridNotation.prototype.parseVariable = function(string) {
      var bits;
      bits = /^\$([^=\s]+)?\s?=\s?(.*)$/i.exec(string);
      if (bits[2] == null) {
        return null;
      }
      return {
        id: bits[1] ? "$" + bits[1] : "$",
        commands: this.parseCommands(bits[2])
      };
    };

    GridNotation.prototype.pipeCleaner = function(string) {
      if (string == null) {
        string = "";
      }
      return string.replace(/[^\S\n]*\|[^\S\n]*/g, '|').replace(/\|+/g, ' | ').replace(/^\s+|\s+$/gm, '');
    };

    GridNotation.prototype.stringifyCommands = function(commands) {
      var command, j, len, string;
      string = "";
      for (j = 0, len = commands.length; j < len; j++) {
        command = commands[j];
        string += " " + this.cmd.stringify(command);
      }
      return this.pipeCleaner(string);
    };

    GridNotation.prototype.stringifyParams = function(params) {
      var string;
      string = "";
      string += "" + (params.orientation || '');
      string += "" + (params.remainder || '');
      string += "" + (params.calculation || '');
      if (params.firstOffset || params.width || params.lastOffset) {
        if (string.length > 0) {
          string += ", ";
        }
      }
      if (params.firstOffset) {
        string += this.cmd.stringify(params.firstOffset);
      }
      if (params.firstOffset || params.width) {
        string += "|";
      }
      if (params.width) {
        string += "" + (this.cmd.stringify(params.width));
      }
      if (params.lastOffset || params.width) {
        string += "|";
      }
      if (params.lastOffset) {
        string += this.cmd.stringify(params.lastOffset);
      }
      if (string) {
        return "( " + (this.pipeCleaner(string)) + " )";
      } else {
        return '';
      }
    };

    return GridNotation;

  })();

  Command = (function() {
    Command.prototype.variableRegexp = /^\$([^\*]+)?(\*(\d+)?)?$/i;

    Command.prototype.explicitRegexp = /^(([-0-9\.]+)?[a-z%]+)(\*(\d+)?)?$/i;

    Command.prototype.wildcardRegexp = /^~(\*(\d*))?$/i;

    function Command(args) {
      if (args == null) {
        args = {};
      }
      this.isWildcard = bind(this.isWildcard, this);
      this.isExplicit = bind(this.isExplicit, this);
      this.isVariable = bind(this.isVariable, this);
      this.unit = new Unit();
    }

    Command.prototype.isGuide = function(command) {
      if (command == null) {
        command = "";
      }
      if (typeof command === "string") {
        return command.replace(/\s/g, '') === "|";
      } else {
        return command.isGuide || false;
      }
    };

    Command.prototype.isVariable = function(command) {
      if (command == null) {
        command = "";
      }
      if (typeof command === "string") {
        return this.variableRegexp.test(command.replace(/\s/g, ''));
      } else {
        return command.isVariable || false;
      }
    };

    Command.prototype.isExplicit = function(command) {
      if (command == null) {
        command = "";
      }
      if (typeof command === "string") {
        if (!this.explicitRegexp.test(command.replace(/\s/g, ''))) {
          return false;
        }
        if (this.unit.parse(command) === null) {
          return false;
        }
        return true;
      } else {
        return command.isExplicit || false;
      }
    };

    Command.prototype.isWildcard = function(command) {
      if (command == null) {
        command = "";
      }
      if (typeof command === "string") {
        return this.wildcardRegexp.test(command.replace(/\s/g, ''));
      } else {
        return command.isWildcard || false;
      }
    };

    Command.prototype.isPercent = function(command) {
      var unit;
      if (command == null) {
        command = "";
      }
      if (typeof command === "string") {
        unit = this.unit.parse(command.replace(/\s/g, ''));
        return (unit != null) && unit.type === '%';
      } else {
        return command.isPercent || false;
      }
    };

    Command.prototype.isFill = function(string) {
      var bits;
      if (string == null) {
        string = "";
      }
      if (this.isVariable(string)) {
        bits = this.variableRegexp.exec(string);
        return bits[2] && !bits[3] || false;
      } else if (this.isExplicit(string)) {
        bits = this.explicitRegexp.exec(string);
        return bits[3] && !bits[4] || false;
      } else if (this.isWildcard(string)) {
        bits = this.wildcardRegexp.exec(string);
        return bits[1] && !bits[2] || false;
      } else {
        return false;
      }
    };

    Command.prototype.count = function(string) {
      if (string == null) {
        string = "";
      }
      string = string.replace(/\s/g, '');
      if (this.isVariable(string)) {
        return parseInt(this.variableRegexp.exec(string)[3]) || 1;
      } else if (this.isExplicit(string)) {
        return parseInt(this.explicitRegexp.exec(string)[4]) || 1;
      } else if (this.isWildcard(string)) {
        return parseInt(this.wildcardRegexp.exec(string)[2]) || 1;
      } else {
        return null;
      }
    };

    Command.prototype.parse = function(string) {
      var bits;
      if (string == null) {
        string = "";
      }
      string = string.replace(/\s/g, '');
      if (this.isGuide(string)) {
        return {
          errors: [],
          isGuide: true
        };
      } else if (this.isVariable(string)) {
        bits = this.variableRegexp.exec(string);
        return {
          errors: [],
          isVariable: true,
          isFill: this.isFill(string),
          id: bits[1] ? "$" + bits[1] : "$",
          multiplier: this.count(string)
        };
      } else if (this.isExplicit(string)) {
        return {
          errors: [],
          isExplicit: true,
          isPercent: this.isPercent(string),
          isFill: this.isFill(string),
          unit: this.unit.parse(string),
          multiplier: this.count(string)
        };
      } else if (this.isWildcard(string)) {
        return {
          errors: this.isFill(string) ? [3] : [],
          isWildcard: true,
          isFill: this.isFill(string),
          multiplier: this.count(string)
        };
      } else {
        return {
          errors: [1],
          string: string
        };
      }
    };

    Command.prototype.stringify = function(command) {
      var string;
      if (command == null) {
        command = "";
      }
      if (typeof command === "string") {
        return command;
      }
      string = "";
      if (command.isGuide) {
        string += "|";
      } else if (command.isVariable) {
        string += command.id;
      } else if (command.isExplicit) {
        string += this.unit.stringify(command.unit);
      } else if (command.isWildcard) {
        string += "~";
      } else {
        if (command.string === "") {
          return "";
        }
        string += command.string;
      }
      if (command.isVariable || command.isExplicit || command.isWildcard) {
        if (command.isFill || command.multiplier > 1) {
          string += '*';
        }
        if (command.multiplier > 1) {
          string += command.multiplier;
        }
      }
      if (command.errors.length === 0) {
        return string;
      } else {
        return "{" + string + " [" + (command.errors.join(',')) + "]}";
      }
    };

    Command.prototype.toSimpleString = function(command) {
      if (command == null) {
        command = "";
      }
      if (typeof command === "string") {
        return command.replace(/\*.*/gi, "");
      }
      return this.stringify(command).replace(/[\{\}]|\*.*|\[\d*\]/gi, "");
    };

    return Command;

  })();

  Unit = (function() {
    Unit.prototype.resolution = 72;

    function Unit(args) {
      if (args == null) {
        args = {};
      }
      this.stringify = bind(this.stringify, this);
      this.parse = bind(this.parse, this);
    }

    Unit.prototype.parse = function(string) {
      var bits, value, zeroAdjustedValue;
      if (string == null) {
        string = "";
      }
      string = string.replace(/\s/g, '');
      bits = string.match(/([-0-9\.]+)([a-z%]+)?/i);
      if (!string || string === "" || (bits == null)) {
        return null;
      }
      if (bits[2] && !this.preferredName(bits[2])) {
        return null;
      }
      if (bits[1] && !bits[2]) {
        zeroAdjustedValue = bits[1].replace(/^\./, '0.');
        value = parseFloat(bits[1]);
        if (value.toString() === zeroAdjustedValue) {
          return value;
        } else {
          return null;
        }
      }
      return {
        string: string,
        value: parseFloat(bits[1]),
        type: this.preferredName(bits[2]),
        base: this.asBaseUnit({
          value: parseFloat(bits[1]),
          type: this.preferredName(bits[2])
        })
      };
    };

    Unit.prototype.preferredName = function(string) {
      switch (string) {
        case 'centimeter':
        case 'centimeters':
        case 'centimetre':
        case 'centimetres':
        case 'cm':
          return 'cm';
        case 'inch':
        case 'inches':
        case 'in':
          return 'in';
        case 'millimeter':
        case 'millimeters':
        case 'millimetre':
        case 'millimetres':
        case 'mm':
          return 'mm';
        case 'pixel':
        case 'pixels':
        case 'px':
          return 'px';
        case 'point':
        case 'points':
        case 'pts':
        case 'pt':
          return 'points';
        case 'pica':
        case 'picas':
          return 'picas';
        case 'percent':
        case 'pct':
        case '%':
          return '%';
        default:
          return null;
      }
    };

    Unit.prototype.asBaseUnit = function(unit) {
      if (!((unit != null) && (unit.value != null) && (unit.type != null))) {
        return null;
      }
      switch (unit.type) {
        case 'cm':
          unit.value = unit.value / 2.54;
          break;
        case 'in':
          unit.value = unit.value / 1;
          break;
        case 'mm':
          unit.value = unit.value / 25.4;
          break;
        case 'px':
          unit.value = unit.value / this.resolution;
          break;
        case 'points':
          unit.value = unit.value / 72;
          break;
        case 'picas':
          unit.value = unit.value / 6;
          break;
        default:
          return null;
      }
      return unit.value * this.resolution;
    };

    Unit.prototype.stringify = function(unit) {
      if (unit == null) {
        unit = "";
      }
      if (unit === "") {
        return null;
      }
      if (typeof unit === "string") {
        return this.stringify(this.parse(unit));
      }
      return "" + unit.value + unit.type;
    };

    return Unit;

  })();

  trim = function(string) {
    return string.replace(/^\s+|\s+$/g, '');
  };

  find = function(arr, iterator) {
    var el, i, j, len, matches;
    if (!(arr && iterator)) {
      return [];
    }
    matches = [];
    for (i = j = 0, len = arr.length; j < len; i = ++j) {
      el = arr[i];
      if (iterator(el) === true) {
        matches.push(el);
      }
    }
    return matches;
  };

  lengthOf = function(command, variables) {
    var j, len, ref, ref1, sum;
    if (!command.isVariable) {
      return command.unit.value * command.multiplier;
    }
    if (!variables[command.id]) {
      return 0;
    }
    sum = 0;
    ref = variables[command.id];
    for (j = 0, len = ref.length; j < len; j++) {
      command = ref[j];
      sum += ((ref1 = command.unit) != null ? ref1.base : void 0) || 0;
    }
    return sum;
  };

  error = function(codes, master, command) {
    var code, exists, j, len;
    if (typeof codes === "number") {
      codes = [codes];
    }
    for (j = 0, len = codes.length; j < len; j++) {
      code = codes[j];
      exists = find(master, (function(e, i) {
        if (e === code) {
          return true;
        }
      })).length > 0;
      if (!exists) {
        master.push(code);
      }
      if (!command) {
        return;
      }
      command.errors || (command.errors = []);
      command.isValid = false;
      exists = find(command.errors, (function(e, i) {
        if (e === code) {
          return true;
        }
      })).length > 0;
      if (!exists) {
        command.errors.push(code);
      }
    }
  };

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = {
      notation: new GridNotation(),
      unit: new Unit(),
      command: new Command()
    };
  } else {
    window.GridNotation = new GridNotation();
    window.Unit = new Unit();
    window.Command = new Command();
  }

}).call(this);
